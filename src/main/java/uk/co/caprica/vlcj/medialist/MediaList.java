package uk.co.caprica.vlcj.medialist;

// FIXME this will replace MediaList asap
// FIXME there may be scope to move some of this to common base class, it is very similar to other code like rendererdiscoverer

// FIXME developer note - when you do insert, or remove, LibVLC is doing retain and release on the media instance, so we don't need to

// FIXME think instead about a java wrapper around libvlc_media_t e.g. for add

// FIXME this stuff with setting media options and what-not, it's done in a few places and we dupe code somewhat (some is in a helper class) and we also need access to standardmediaoptions which we don't have right now
// maybe we just say standardmediaoptions on mediaplayer can't be used with this api, we could add standard mediaoptions for the list though... and in the other place... subitems standardoptions, might even work better actually!
// FIXME also i suspect there's no reason we can't allow all vlcj MediaTypes here, well at least Simple and Callback? as long as a media instance is returned
//  it's almost like the createMediaInstance method in MediaService should have its implemention pulled out into static class
// FIXME maybe even do away with the concept of standard media options ENTIRELY and make that a client job

import com.sun.jna.CallbackThreadInitializer;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import uk.co.caprica.vlcj.binding.LibVlc;
import uk.co.caprica.vlcj.binding.internal.*;
import uk.co.caprica.vlcj.player.events.medialist.MediaListEvent;
import uk.co.caprica.vlcj.player.events.medialist.MediaListEventFactory;
import uk.co.caprica.vlcj.player.MediaResourceLocator;
import uk.co.caprica.vlcj.player.NativeString;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public final class MediaList {

    private final LibVlc libvlc;

    private final libvlc_instance_t libvlcInstance;

    private final libvlc_media_list_t mediaList;

    private final libvlc_event_manager_t eventManager;

    /**
     * Collection of media player event listeners.
     * <p>
     * A {@link CopyOnWriteArrayList} is used defensively so as not to interfere with the processing of any existing
     * events that may be being generated by the native callback in the unlikely case that a listeners is being added or
     * removed.
     */
    private final List<MediaListEventListener> eventListenerList = new CopyOnWriteArrayList<MediaListEventListener>();

    /**
     * Call-back to handle native media player events.
     */
    private final DiscovererCallback callback = new DiscovererCallback();

    // FIXME should allow to create without ctor
    //  need to check about retaining the initial media_list... it's a PITA because sometimes i do, sometimes i don't - i think... check where it's ctors are used, probably the caller should make sure it's retained

    /**
     * Create a new media list.
     *
     * @param libvlc
     * @param libvlcInstance
     */
    public MediaList(LibVlc libvlc, libvlc_instance_t libvlcInstance) {
        this(libvlc, libvlcInstance, null);
    }

    /**
     * Create a new media list.
     *
     * @param libvlc
     * @param libvlcInstance
     * @param mediaList native media list, the caller must not release this opaque handle, it will be released by this component when it is no longer needed
     */
    public MediaList(LibVlc libvlc, libvlc_instance_t libvlcInstance, libvlc_media_list_t mediaList) {
        this.libvlc = libvlc;
        this.libvlcInstance = libvlcInstance;
        this.mediaList = mediaList != null ? mediaList : newNativeMediaList();

        this.eventManager = libvlc.libvlc_media_list_event_manager(this.mediaList);

        registerNativeEventListener();
    }

    private libvlc_media_list_t newNativeMediaList() {
        libvlc_media_list_t result = libvlc.libvlc_media_list_new(libvlcInstance);
        if (result != null) {
            return result;
        } else {
            throw new RuntimeException("Failed to get a new native media list instance");
        }
    }

    public void addMediaListEventListener(MediaListEventListener listener) {
        eventListenerList.add(listener);
    }

    public void removeMediaListEventListener(MediaListEventListener listener) {
        eventListenerList.remove(listener);
    }

    public boolean isReadOnly() {
        return libvlc.libvlc_media_list_is_readonly(mediaList) == 0;
    }

    /**
     * Get the number of items currently in the list.
     *
     * @return item count
     */
    public int size() {
        lock();
        try {
            return libvlc.libvlc_media_list_count(mediaList);
        }
        finally {
            unlock();
        }
    }

    public String mrl(int index) {
        lock();
        try {
            libvlc_media_t media = libvlc.libvlc_media_list_item_at_index(mediaList, index);
            if (media != null) {
                try {
                    return NativeString.copyNativeString(libvlc.libvlc_media_get_mrl(media));
                }
                finally {
                    libvlc.libvlc_media_release(media);
                }
            } else {
                return null;
            }

        }
        finally {
            unlock();
        }
    }

    public List<String> items() {
        lock();
        try {
            int count = libvlc.libvlc_media_list_count(mediaList);
            List<String> result = new ArrayList<String>(count);
            for (int i = 0; i < count; i++) {
                libvlc_media_t item = libvlc.libvlc_media_list_item_at_index(mediaList, i);
                result.add(NativeString.copyNativeString(libvlc.libvlc_media_get_mrl(item)));
                libvlc.libvlc_media_release(item);
            }
            return result;
        }
        finally {
            unlock();
        }
    }

    /**
     * Add a media item, with options, to the play-list.
     *
     * @param mrl media resource locator
     * @param mediaOptions zero or more media item options
     */
    public boolean addMedia(String mrl, String... mediaOptions) {
        lock();
        try {
            return libvlc.libvlc_media_list_add_media(mediaList, newMedia(mrl, mediaOptions)) == 0;
        }
        finally {
            unlock();
        }
    }

    /**
     * Insert a media item, with options, to the play-list.
     *
     * @param index position at which to insert the media item (counting from zero)
     * @param mrl media resource locator
     * @param mediaOptions zero or more media item options
     */
    public boolean insertMedia(int index, String mrl, String... mediaOptions) {
        lock();
        try {
            return libvlc.libvlc_media_list_insert_media(mediaList, newMedia(mrl, mediaOptions), index) == 0;
        }
        finally {
            unlock();
        }
    }

    /**
     * Remove a media item from the play-list.
     *
     * @param index item to remove (counting from zero)
     */
    public boolean removeMedia(int index) {
        lock();
        try {
            // Internally LibVLC is already releasing the media instance
            return libvlc.libvlc_media_list_remove_index(mediaList, index) == 0;
        }
        finally {
            unlock();
        }
    }

    /**
     * Clear the list.
     */
    public void clear() {
        lock();
        try {
            // Traverse backwards to preserve indices
            for (int i = libvlc.libvlc_media_list_count(mediaList) - 1; i >= 0; i--) {
                // Internally LibVLC is already releasing the media instance
                libvlc.libvlc_media_list_remove_index(mediaList, i);
            }
        }
        finally {
            unlock();
        }
    }

    public final libvlc_media_list_t mediaListInstance() {
        return mediaList;
    }

    public void release() {
        eventListenerList.clear();
        deregisterNativeEventListener();
        libvlc.libvlc_media_list_release(mediaList);
    }

    private void registerNativeEventListener() {
        for (libvlc_event_e event : libvlc_event_e.values()) {
            if (event.intValue() >= libvlc_event_e.libvlc_MediaListItemAdded.intValue() && event.intValue() <= libvlc_event_e.libvlc_MediaListEndReached.intValue()) {
                libvlc.libvlc_event_attach(eventManager, event.intValue(), callback, null);
            }
        }
    }

    private void deregisterNativeEventListener() {
        for (libvlc_event_e event : libvlc_event_e.values()) {
            if (event.intValue() >= libvlc_event_e.libvlc_MediaListItemAdded.intValue() && event.intValue() <= libvlc_event_e.libvlc_MediaListEndReached.intValue()) {
                libvlc.libvlc_event_detach(eventManager, event.intValue(), callback, null);
            }
        }
    }

    private void lock() {
        libvlc.libvlc_media_list_lock(mediaList);
    }

    private void unlock() {
        libvlc.libvlc_media_list_unlock(mediaList);
    }

    private libvlc_media_t newMedia(String mrl, String... mediaOptions) {
        libvlc_media_t media;
        mrl = MediaResourceLocator.encodeMrl(mrl);
        if (MediaResourceLocator.isLocation(mrl)) {
            media = libvlc.libvlc_media_new_location(libvlcInstance, mrl);
        } else {
            media = libvlc.libvlc_media_new_path(libvlcInstance, mrl);
        }
        MediaOptions.addMediaOptions(libvlc, media, mediaOptions);
        return media;
    }

    /**
     * Raise a new event (dispatch it to listeners).
     * <p>
     * Events are processed on the <em>native</em> callback thread, so must execute quickly and certainly must never
     * block.
     * <p>
     * It is also generally <em>forbidden</em> for an event handler to call back into LibVLC.
     *
     * @param mediaListEvent event to raise, may be <code>null</code> and if so will be ignored
     */
    void raiseEvent(MediaListEvent mediaListEvent) {
        if (mediaListEvent != null) {
            for (MediaListEventListener listener : eventListenerList) {
                mediaListEvent.notify(listener);
            }
        }
    }

    private class DiscovererCallback implements libvlc_callback_t {

        private DiscovererCallback() {
            Native.setCallbackThreadInitializer(this, new CallbackThreadInitializer(true, false, "media-discoverer"));
        }

        @Override
        public void callback(libvlc_event_t event, Pointer userData) {
            raiseEvent(MediaListEventFactory.createEvent(MediaList.this, event));
        }

    }

}
