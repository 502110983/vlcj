package uk.co.caprica.vlcj.player.base;

import com.sun.jna.CallbackThreadInitializer;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import uk.co.caprica.vlcj.binding.internal.libvlc_callback_t;
import uk.co.caprica.vlcj.binding.internal.libvlc_event_e;
import uk.co.caprica.vlcj.binding.internal.libvlc_event_manager_t;
import uk.co.caprica.vlcj.binding.internal.libvlc_event_t;
import uk.co.caprica.vlcj.player.MediaPlayerEventListener;
import uk.co.caprica.vlcj.player.events.MediaPlayerEvent;
import uk.co.caprica.vlcj.player.events.standard.StandardEventFactory;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public final class EventService extends BaseService {

    /**
     * Native media player event manager.
     */
    private final libvlc_event_manager_t mediaPlayerEventManager;

    /**
     * Collection of media player event listeners.
     * <p>
     * A {@link CopyOnWriteArrayList} is used defensively so as not to interfere with the processing of any existing
     * events that may be being generated by the native callback in the unlikely case that a listeners is being added or
     * removed.
     */
    private final List<MediaPlayerEventListener> eventListenerList = new CopyOnWriteArrayList<MediaPlayerEventListener>();

    /**
     * Call-back to handle native media player events.
     */
    private final MediaPlayerEventCallback callback = new MediaPlayerEventCallback();

    EventService(DefaultMediaPlayer mediaPlayer) {
        super(mediaPlayer);

        this.mediaPlayerEventManager = getNativeMediaPlayerEventManager();

        // Add event handlers used for internal implementation
        addMediaPlayerEventListener(new RepeatPlayEventHandler      ());
        addMediaPlayerEventListener(new MediaPlayerReadyEventHandler());

        registerNativeEventListener();
    }

    private libvlc_event_manager_t getNativeMediaPlayerEventManager() {
        libvlc_event_manager_t result = libvlc.libvlc_media_player_event_manager(mediaPlayerInstance);
        if (result != null) {
            return result;
        } else {
            throw new RuntimeException("Failed to get the native media player event manager instance");
        }
    }

    /**
     * Add a component to be notified of media player events.
     *
     * @param listener component to notify
     */
    public void addMediaPlayerEventListener(MediaPlayerEventListener listener) {
        eventListenerList.add(listener);
    }

    /**
     * Remove a component that was previously interested in notifications of media player events.
     *
     * @param listener component to stop notifying
     */
    public void removeMediaPlayerEventListener(MediaPlayerEventListener listener) {
        eventListenerList.remove(listener);
    }

    private void registerNativeEventListener() {
        for (libvlc_event_e event : libvlc_event_e.values()) {
            if (event.intValue() >= libvlc_event_e.libvlc_MediaPlayerMediaChanged.intValue() && event.intValue() <= libvlc_event_e.libvlc_MediaPlayerChapterChanged.intValue()) {
                libvlc.libvlc_event_attach(mediaPlayerEventManager, event.intValue(), callback, null);
            }
        }
    }

    private void deregisterNativeEventListener() {
        if (mediaPlayerEventManager != null) {
            for (libvlc_event_e event : libvlc_event_e.values()) {
                if (event.intValue() >= libvlc_event_e.libvlc_MediaPlayerMediaChanged.intValue() && event.intValue() <= libvlc_event_e.libvlc_MediaPlayerChapterChanged.intValue()) {
                    libvlc.libvlc_event_detach(mediaPlayerEventManager, event.intValue(), callback, null);
                }
            }
        }
    }

    /**
     * Raise a new event (dispatch it to listeners).
     * <p>
     * Events are processed on the <em>native</em> callback thread, so must execute quickly and certainly must never
     * block.
     * <p>
     * It is also generally <em>forbidden</em> for an event handler to call back into LibVLC.
     *
     * @param mediaPlayerEvent event to raise, may be <code>null</code> and if so will be ignored
     */
    void raiseEvent(final MediaPlayerEvent mediaPlayerEvent) {
        if (mediaPlayerEvent != null) {
            for (MediaPlayerEventListener listener : eventListenerList) {
                mediaPlayerEvent.notify(listener);
            }
        }
    }

    private class MediaPlayerEventCallback implements libvlc_callback_t {

        private MediaPlayerEventCallback() {
            Native.setCallbackThreadInitializer(this, new CallbackThreadInitializer(true, false, "media-player-events"));
        }

        @Override
        public void callback(libvlc_event_t event, Pointer userData) {
            raiseEvent(StandardEventFactory.createEvent(mediaPlayer, event));
        }
    }

    @Override
    protected void release() {
        eventListenerList.clear();

        deregisterNativeEventListener();
    }

}
